%_______________________________________________________________________________________%
%  source code:  GGWO: Gaze cues learning-based grey wolf optimizer and                 %
%                its applications for solving engineering problems                      %
%                                                                                       %
%  Developed in: MATLAB R2018a                                                          %
% --------------------------------------------------------------------------------------%
%  Main paper:   GGWO: Gaze cues learning-based grey wolf optimizer and                 %
%                its applications for solving engineering problems                      %
%                Mohammad H Nadimi-Shahraki, Shokooh Taghian, Seyedali Mirjalili,       %
%                Hoda Zamani, Ardeshir Bahreininejad                                    %
%                Journal of Computational Science                                       %
%                Volume 61, May 2022, 101636                                            %
%                DOI: 10.1016/j.jocs.2022.101636                                        %
%                https://www.sciencedirect.com/science/article/pii/S1877750322000588    %
%                                                                                       %
%  Emails:       nadimi@ieee.org, shokooh.taghian94@gmail.com, ali.mirjalili@gmail.com, %
%                hoda_zamani@yahoo.com, bahreininejad@gmail.com                        %
%_______________________________________________________________________________________%

% GGWO: Gaze cues learning-based grey wolf optimizer
function [Fbest,Lbest,Convergence_curve] = GGWO(dim,N,Max_iter,lb,ub,fobj)

lu = [lb .* ones(1, dim); ub .* ones(1, dim)];
ub = ub*ones(1,dim);
lb = lb*ones(1,dim);

iter = 0; % Loop counter
Fm = 0.5; c = 0.1; % Parameters used for calculating scale factor F

%% Initialization 

% Initialize alpha, beta, and delta_pos
Alpha_pos = zeros(1,dim);
Alpha_score = inf; %change this to -inf for maximization problems

Beta_pos = zeros(1,dim);
Beta_score = inf; %change this to -inf for maximization problems

Delta_pos = zeros(1,dim);
Delta_score = inf; %change this to -inf for maximization problems

%Initialize the positions of wolves
Positions = initialization(N,dim,ub,lb);
Positions = boundrycheck(Positions, Positions, lu);

% Calculate objective function for each wolf
for i=1:size(Positions,1)
    Fit(i) = fobj(Positions(i,:));
end

pBestScore = Fit;
pBest = Positions;

[gbest_val,Idx] = min(Fit);
gbest_pos = Positions(Idx,:);

Convergence_curve=zeros(1,Max_iter);

%% Main loop
while iter < Max_iter
    for i = 1:N
        fitness = Fit(i);
        
        % Update Alpha, Beta, and Delta
        if fitness < Alpha_score
            Alpha_score = fitness; % Update alpha
            Alpha_pos = Positions(i,:);
        end
        
        if fitness > Alpha_score && fitness < Beta_score
            Beta_score = fitness; % Update beta
            Beta_pos = Positions(i,:);
        end
        
        if fitness > Alpha_score && fitness > Beta_score && fitness < Delta_score
            Delta_score = fitness; % Update delta
            Delta_pos = Positions(i,:);
        end
    end
%% Movement step including "The original GWO strategy", "NGCL" and "RGCL"    

    % The original GWO strategy
    a = 2-iter*((2)/Max_iter); % Eq. (5), a decreases linearly fron 2 to 0
    
    % Update the Position of wolves including omegas
    for i = 1:N
        for j = 1:dim
            r1 = rand(); % r1 is a random number in [0,1]
            r2 = rand(); % r2 is a random number in [0,1]
            
            A1 = 2*a*r1-a; % Eq.(3)
            C1 = 2*r2; % Eq.(4)
            
            D_alpha = abs(C1*Alpha_pos(j)-Positions(i,j)); % Eq.(6)-part 1
            X1 = Alpha_pos(j)-A1*D_alpha; % Eq.(7)-part 1
            
            r1 = rand();
            r2 = rand();
            
            A2 = 2*a*r1-a; % Eq.(3)
            C2 = 2*r2; % Eq.(4)
            
            D_beta = abs(C2*Beta_pos(j)-Positions(i,j)); % Eq.(6)-part 2
            X2 = Beta_pos(j)-A2*D_beta; % Eq.(7)-part 2
            
            r1 = rand();
            r2 = rand();
            
            A3 = 2*a*r1-a; % Eq.(3)
            C3 = 2*r2; % Eq.(4)
            
            D_delta = abs(C3*Delta_pos(j)-Positions(i,j)); % Eq.(6)-part 3
            X3 = Delta_pos(j)-A3*D_delta; % Eq.(7)-part 3
            
            X_GWO(i,j) = (X1+X2+X3)/3; % Eq.(8)
            
        end
        X_GWO(i,:) = boundrycheck(X_GWO(i,:), Positions(i,:), lu);  % X_GWO: the candidate positions generated by the original GWO strategy
        Fit_GWO(i) = fobj(X_GWO(i,:));
    end
    
    %% NGCL and RGCL search strategies
    % NGCL: Neighbor gaze cues learning search strategy
    % RGCL: Random gaze cues learning search strategy
    
    %-------Set parametrs used in NGCL and RGCL------------------------------%    
    r1 = randperm(N,N); 
    r2 = randperm(N,N);
    
    % Calculating scale factor F
    if iter > 1 && sum(goodF) > 0 
        Fm = (1 - c) * Fm + c * sum(goodF .^ 2) / sum(goodF); 
    end
    F = randF(N, Fm, 0.1); % Generate F according to a cauchy distribution
    
    %-------Finding immediate neighbors of each wolf using in NGCL-----------%
    [sorted_Fit Idx] = sort(Fit,'ascend');
    for i = 1:N
        for d = 1:dim
            if i==1
                neighbor = [N-1 N i+1 i+2];
                j = randperm(4);
                Ni(i,d) = Idx(neighbor(j(2)));
            end
            if i==2
                neighbor = [N i-1 i+1 i+2];
                j = randperm(4);
                Ni(i,d) = Idx(neighbor(j(2)));
            end
            if i==N-1
                neighbor = [i-2 i-1 N 1];
                j = randperm(4);
                Ni(i,d) = Idx(neighbor(j(2)));
            end
            if i==N
                neighbor = [i-2 i-1 1 2];
                j = randperm(4);
                Ni(i,d) = Idx(neighbor(j(2)));
            end
            if i~=[1 2 N-1 N]
                neighbor = [i-2 i-1 i+1 i+2];
                j = randperm(4);
                Ni(i,d) = Idx(neighbor(j(2)));
            end
            
        end %dim
    end %Pop
        
    %-------Generating candidate solutions for NGCL and RGCL search strategies-----------%
    for i = 1:N
        for d = 1:dim
            X_NGCL(i,d) = Alpha_pos(1,d) + F(i) .*(Positions(Ni(i,d),d) - Positions(i,d)); % Eq. (10)
            X_RGCL(i,d) = Positions(i,d) + F(i) .*(Positions(r1(i),d)-Positions(r2(i),d)); % Eq. (13)
        end
        X_NGCL(i,:) = boundrycheck(X_NGCL(i,:), Positions(i,:), lu);
        X_RGCL(i,:) = boundrycheck(X_RGCL(i,:), Positions(i,:), lu);
        
        Fit_NGCL(i) = fobj(X_NGCL(i,:));
        Fit_RGCL(i) = fobj(X_RGCL(i,:));
    end
    
    %% Selecting and updating step
    % X_can: the selected candidate positions between X_GWO, X_NGCL, and X_RGCL with minimum fitness value
    
    tmp = Fit_NGCL <= Fit_RGCL;
    tmp_rep = repmat(tmp',1,dim);
    
    Fit_tmp = tmp .* Fit_NGCL + (1-tmp) .* Fit_RGCL;
    X_tmp = tmp_rep .* X_NGCL + (1-tmp_rep) .* X_RGCL;  
    %------------------------------------------------------------
    tmp = Fit_GWO <= Fit_tmp;
    tmp_rep = repmat(tmp',1,dim);
    
    Fit_can = tmp .* Fit_GWO + (1-tmp) .* Fit_tmp;
    X_can = tmp_rep .* X_GWO + (1-tmp_rep) .* X_tmp;
    %------------------------------------------------------------
    goodF = F(tmp == 0); % to find the Sf 
     
    %------------------------------------------------------------
    tmp = Fit <= Fit_can; % Eq. (14)
    tmp_rep = repmat(tmp',1,dim);
    
    Fit = tmp .* Fit + (1-tmp) .* Fit_can;
    Positions = tmp_rep .* Positions + (1-tmp_rep) .* X_can;
    
    %%
    iter = iter + 1;    
    Convergence_curve = [Convergence_curve Alpha_score];
    
end

[sorted_Fit, Idx] = sort(Fit, 'ascend');
Alpha_score = sorted_Fit(1); % Update alpha
Alpha_pos = Positions(Idx(1),:);

Fbest = Alpha_score;
Lbest = Alpha_pos;
end




